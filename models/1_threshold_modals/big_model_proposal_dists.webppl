var limitedDiscreteUniform = cache(function(a, b) {
  return Infer({
    method: "enumerate"
  }, function() {
    var bins = _.range(a, b + 1, 5);
    var probs = map(function(x) {
      return 1 / bins.length;
    }, bins);
    return bins[discrete(probs)];
  });
});

var discreteUniform = limitedDiscreteUniform(0, 100);

var discreteBeta = cache(function(params) {
  return Infer({
    method: "enumerate"
  }, function() {
    var bins = _.range(0, 1.01, .05);
    var probs = map(function(b) {
      Math.exp(Beta(params).score(b))
    }, bins);
    var ret = bins[discrete(probs)];
    return ret;
  })
});

var thetaParamDist = Infer({
  method: "enumerate"
}, function() {
  var bins = _.range(0.1, 30.1, 0.5);
  var probs = map(function(x) {
    return 1 / bins.length;
  }, bins);
  var ret = bins[discrete(probs)];
  return ret;
});


var thetaParamPrior = function() {
  return sample(Uniform({
    a: 0,
    b: 30
  }));
}

var costPrior = function() {
  return sample(Uniform({
    a: 0,
    b: 5
  }));
}

var ratPrior = function() {
  return sample(Uniform({
    a: 0.1,
    b: 3
  }));
}

var thetaParamPrior2 = function(mu, sigma, width) {
  return gaussianDrift({mu: mu, sigma: sigma, width: width});
}

var costPrior2 = thetaParamPrior2;

var ratPrior2 = thetaParamPrior2;


var thetaPrior = function() {
  return sample(discreteUniform)
}


var probPrior = function() {
  return sample(discreteUniform)
}

var utterances = ["bare", "might", "looks_like", "probably", "think", "could", "bare not"]



var utterancePrior = function() {
  return uniformDraw(utterances);
}

var literalListener = function(utterance, theta) {
  if (flip(0.05)) {
    return discreteUniform; //to account for noise
  } else if (utterance == "bare not") {
    return limitedDiscreteUniform(0, theta);
  } else {
    return limitedDiscreteUniform(theta, 100);
  }
};


var thetas_tmp = {
  might: 50,
  bare: 90
};
var pragmaticSpeaker = cache(function(prob, alphas, betas, costs, rat_alpha, modal1, modal2) {

  var theta_dists = mapObject(function (key, value) {
    return discreteBeta({
      a: alphas[key],
      b: betas[key]
    });
  
  }, alphas);
  return Infer({
    model: function() {
      var utt = utterancePrior();
      var cost = (utt == modal1 || utt == modal2) ? 0 : costs[utt];
      var theta = utt == "bare not" ? 100 - Math.round(sample(theta_dists["bare"]) * 100) : Math.round(sample(theta_dists[utt]) * 100);
      factor(rat_alpha * (literalListener(utt, theta).score(prob) - cost));
      return (utt == modal1 || utt == modal2) ? utt : "other";
    },
    method: "enumerate"
  });
});

var model = function() {
  return thetaParamPosterior();
}

var makeResult = function(alphas, betas, costs, rat_alpha) {
  return {
    alpha_bare: alphas["bare"],
    alpha_might: alphas["might"],
    alpha_looks_like: alphas["looks_like"],
    alpha_probably: alphas["probably"],
    alpha_think: alphas["think"],
    alpha_could: alphas["could"],
    beta_bare: betas["bare"],
    beta_might: betas["might"],
    beta_looks_like: betas["looks_like"],
    beta_probably: betas["probably"],
    beta_think: betas["think"],
    beta_could: betas["could"],
    cost_bare: costs["bare"],
    cost_might: costs["might"],
    cost_looks_like: costs["looks_like"],
    cost_probably: costs["probably"],
    cost_think: costs["think"],
    cost_could: costs["could"],
    cost_bare_not: costs["bare not"],
    rat_alpha: rat_alpha
  };
}

var thetaParamPosterior = function() {
  var alphas = {
    "bare": thetaParamPrior2(2, 2, 0.2),
    "might": thetaParamPrior2(0.5, 0.5, 0.2),
    "looks_like": thetaParamPrior2(3.1, 2, 0.2),
    "probably": thetaParamPrior2(5, 2, 0.2),
    "think": thetaParamPrior2(2.6, 2, 0.2),
    "could": thetaParamPrior2(0.8, 0.8, 0.2)
  };


  var betas = {
    "bare": thetaParamPrior2(0.005, 0.5, 0.02),
    "might": thetaParamPrior2(4.2, 2, 0.2),
    "looks_like": thetaParamPrior2(1.1, 1.1, 0.2),
    "probably": thetaParamPrior2(3.3, 2, 0.2),
    "think": thetaParamPrior2(1.7, 1.7, 0.2),
    "could": thetaParamPrior2(2.5, 2, 0.2)
  };



  var rat_alpha = ratPrior2(1.5, 0.5, 0.1);

  var costs = {
    "bare": costPrior2(1.8, 1, 0.1),
    "might": costPrior2(0.7, 0.7, 0.1),
    "looks_like": costPrior2(4.1, 1, 0.1),
    "probably": costPrior2(4.3, 1, 0.1),
    "think": costPrior2(1.7, 1, 0.1),
    "could": costPrior2(1.3, 1, 0.1),
    "bare not": costPrior2(1, 1, 0.1)
  };


  //check if all params are positive
  if (rat_alpha < 0) {
    condition(false);
  }
  
  mapObject(function (key, value) {
    if (value < 0) {
      condition(false);
    }
  }, costs);
  
  mapObject(function (key, value) {
    if (value < 0) {
      condition(false);
    }
  }, alphas);
  
  mapObject(function (key, value) {
    if (value < 0) {
      condition(false);
    }
  }, betas);


  map(function(d) {

    var p = d.percentage_blue;
    var utt = d.modal;
    observe(pragmaticSpeaker(p, alphas, betas, costs, rat_alpha, d.modal1, d.modal2),
      utt);
  }, data.obs);
  return makeResult(alphas, betas, costs, rat_alpha);
}


Infer(JSON.parse('{"method":"MCMC","burn":500,"samples":10000, "verbose": true}'), model)