---
title: "model convergence"
author: "Sebastian Schuster"
date: "4/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r fcts, include=FALSE}
library(rwebppl)
library(dplyr)
library(tidyverse)


convertData = function(output_file) {

output_string <- paste(readLines(output_file, warn = F),
                       collapse = "\n")
if (output_string != "") {
  output <- jsonlite::fromJSON(output_string, flatten = TRUE)
  if (!is.null(names(output))) {
    return(tidy_output(output, chains = 1,
                       chain = 1))
  }
}
}

is_mcmc <- function(output) {
  ((names(output)[1] == "score") & 
     all(grepl("value", names(output)[2:length(names(output))])))
}

is_rejection <- function(output) {
  all(grepl("value", names(output)))
}

is_sampleList <- function(output) {
  is_mcmc(output) || is_rejection(output)
}

is_probTable <- function(output){
  all(names(output) %in% c("probs", "support"))
}

isOptimizeParams <- function(output){
  (all(c("dims", "length") %in% names(output[[1]])) &&
     all(c("dims", "length") %in% names(output[[length(output)]])))
}

# Try to use inference_opts to determine # samples; otherwise use size of list
countSamples <- function(output, inference_opts) {
  if(!(is.null(inference_opts[["samples"]]))) {
    return(inference_opts[["samples"]])
  } else if (!(is.null(inference_opts[["particles"]]))) {
    return(inference_opts[["particles"]])
  } else {
    return(nrow(output))
  }
}

tidy_probTable <- function(output) {
  if (class(output$support) == "data.frame") {
    support <- output$support
  } else {
    support <- data.frame(support = output$support)
  }
  return(cbind(support, data.frame(prob = output$probs)))
}

tidy_sampleList <- function(output, chains, chain, inference_opts) {
  names(output) <- gsub("value.", "", names(output))
  num_samples <- countSamples(output, inference_opts)
  # as of webppl v0.9.6, samples come out in the order they were collected
  output$Iteration <- 1:num_samples 
  ggmcmc_samples <- tidyr::gather_(
    output, key_col = "Parameter", value_col = "value",
    gather_cols = names(output)[names(output) != "Iteration"],
    factor_key = TRUE
  )
  ggmcmc_samples$Chain <- chain
  ggmcmc_samples <- ggmcmc_samples[,c("Iteration", "Chain", "Parameter", "value")] # reorder columns
  attr(ggmcmc_samples, "nChains") <- chains
  attr(ggmcmc_samples, "nParameters") <- ncol(output) - 1
  attr(ggmcmc_samples, "nIterations") <- num_samples
  attr(ggmcmc_samples, "nBurnin") <- ifelse(is.null(inference_opts[["burn"]]), 0, inference_opts[["burn"]])
  attr(ggmcmc_samples, "nThin") <- ifelse(is.null(inference_opts[["thin"]]), 1, inference_opts[["thin"]])
  attr(ggmcmc_samples, "description") <- ifelse(is.null(inference_opts[["method"]]), "", inference_opts[["method"]])
  return(ggmcmc_samples)
}

tidy_output <- function(output, chains = NULL, chain = NULL, inference_opts = NULL) {
  if (is_probTable(output)) {
    return(tidy_probTable(output))
  } else if (is_sampleList(output)) {
    # Drop redundant score column, if it exists
    if ("score" %in% names(output)) { 
      output <- output[, names(output) != 'score', drop = F]
    } 
    return(tidy_sampleList(output, chains, chain, inference_opts))
  } else {
    return(output)
  }
}


estimate_mode <- function(x) {
  d <- density(x)
  d$x[which.max(d$y)]
}



```


```{r, echo=FALSE}

outputfile = "./output_all_run1.json"

params = convertData(outputfile) %>% 
 # filter(Iteration == max(.$Iteration))
  filter(Iteration > 0)

params$Chain = 1
  
for (i in seq(2,3)) {
  outputfile = paste("./output_all_run", i, ".json", sep="")
  params2 = convertData(outputfile) %>%
    filter(Iteration > 0)
  
  params2$Chain = i
  params = rbind(params, params2)
}

final_params_all = params %>% group_by(Parameter) %>% summarise(med=median(value), mu = mean(value), mode = estimate_mode(value), low=quantile(value, 0.025), high=quantile(value, 0.975), sd_all=sd(value))
final_params_by_chain = params %>% group_by(Parameter, Chain) %>% summarise(med=median(value), mu = mean(value), mode = estimate_mode(value), low=quantile(value, 0.025), high=quantile(value, 0.975), sd=sd(value))

final_params_merged = merge(final_params_by_chain, final_params_all, by=c("Parameter"))

final_params_merged$R_hat = final_params_merged$sd_all / final_params_merged$sd

#final_params_merged[, c("Parameter", "sd", "sd_all", "R_hat")]

beta_params = params %>% filter(., grepl("cost|rat", Parameter) == FALSE)
alpha_rat_params = params %>% filter(., grepl("rat_alpha", Parameter))
cost_params = params %>% filter(., grepl("cost", Parameter))

```

```{r fig1, fig.width=10, echo=FALSE}

ggplot(alpha_rat_params %>% filter(Iteration > 0), aes(x=Iteration, y=value, col=Parameter)) + geom_line() + facet_wrap(~Chain)
ggplot(cost_params %>% filter(Iteration > 0), aes(x=Iteration, y=value, col=Parameter)) + geom_line() + facet_wrap(~Chain)
ggplot(beta_params %>% filter(Iteration > 0), aes(x=Iteration, y=value, col=Parameter)) + geom_line() + facet_wrap(~Chain)

```